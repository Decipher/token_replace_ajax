<?php

/**
 * @file
 * Core functions for Token replace AJAX.
 */

/**
 * Implements hook_menu().
 */
function token_replace_ajax_menu() {
  $items['token_replace/ajax/%'] = array(
    'page callback'    => 'token_replace_ajax_callback',
    'page arguments'   => array(2),
    'access callback'  => 'token_replace_ajax_access_callback',
    'access arguments' => array(2),
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function token_replace_ajax_permission() {
  return array(
    'access token_replace_ajax callback' => array(
      'title' => t('Access Token replace AJAX callback'),
    ),
  );
}

/**
 * Implements hook_custom_theme().
 */
function token_replace_ajax_custom_theme() {
  // Ensure that if this is a valid POST request that we use the same theme
  // used by the referring form.
  if (isset($_POST['form_build_id'])) {
    $form_state    = form_state_defaults();
    $form_build_id = $_POST['form_build_id'];
    $form          = form_get_cache($form_build_id, $form_state);
    if (!is_null($form)) {
      global $base_path;

      $path = preg_replace('/' . str_replace('/', '\/', $base_path) . '/', '', $form['#action'], 1);
      if (path_is_admin($path)) {
        return variable_get('admin_theme');
      }
    }
  }

  return FALSE;
}

/**
 * Access callback for Token replace AJAX.
 */
function token_replace_ajax_access_callback($token = '') {
  // Ensure that we get the token if it is provided.
  // @TODO - Determine why this is needed, as it should always be provided, but
  // it appears that isn't if it is a POST request.
  if (empty($token) && arg(2) != '') {
    $token = arg(2);
  }

  // Return FALSE if no token is provided.
  if (empty($token)) {
    return FALSE;
  }

  // Check if user has permission.
  if (user_access('access token_replace_ajax callback')) {
    return TRUE;
  }

  // Check if an access key has been provided and it matches the required key
  // for the requested token.
  elseif (isset($_GET['key']) && $_GET['key'] == token_replace_ajax_access_key($token)) {
    return TRUE;
  }

  // Check if this is a POST callback from a valid Drupal form.
  elseif (isset($_POST['form_build_id'])) {
    $form_state    = form_state_defaults();
    $form_build_id = $_POST['form_build_id'];
    $form          = form_get_cache($form_build_id, $form_state);
    if (!is_null($form) && isset($form['token_replace_ajax']['#value'])) {
      return $form['token_replace_ajax']['#value'] == TRUE;
    }
  }

  return FALSE;
}

/**
 * Menu callback for Token replace AJAX.
 */
function token_replace_ajax_callback($token = '') {
  $data = array();

  // Get Entity for token context from supplied arguments.
  if (isset($_REQUEST['entity_type']) && isset($_REQUEST['entity_id'])) {
    $entity_type = $_REQUEST['entity_type'];
    $entities    = entity_load($entity_type, array($_REQUEST['entity_id']));
    $entity      = reset($entities);
  }

  // Get Entity for token context from posted form.
  elseif (isset($_POST['form_build_id'])) {
    // @TODO - Allow for '#limit_validation_errors' to be passed in..
    list($form, $form_state, $form_id, $form_build_id, $commands) = ajax_get_form();
    $form_state['programmed'] = TRUE;
    drupal_process_form($form['#form_id'], $form, $form_state);

    $entity_type = $form['#entity_type'];
    $entity_info = entity_get_info($entity_type);
    $entity      = (object) array_merge((array) $form["#entity"], isset($form_state['values']) ? $form_state['values'] : array());

    // Add a dummy entity ID if none exists.
    $entity->{$entity_info['entity keys']['id']} = isset($entity->{$entity_info['entity keys']['id']}) ? $entity->{$entity_info['entity keys']['id']} : 0;

    field_attach_prepare_view($entity_type, array($entity->{$entity_info['entity keys']['id']} => $entity), 'full');
  }

  if (isset($entity_type) && isset($entity)) {
    $data[$entity_type] = $entity;
  }

  print json_encode(array(
    'token'    => $token,
    'value'    => token_replace($token, $data),
    'messages' => array(
      'data' => drupal_get_messages(NULL, FALSE),
      'html' => theme('status_messages'),
    ),
  ));
  drupal_exit();
}

/**
 * Implements hook_field_display_alter().
 */
function token_replace_ajax_field_display_alter(&$display, $context) {
  list($id, $vid, $bundle_name) = entity_extract_ids($context['entity_type'], $context['entity']);

  // If this is a dummy entity provided by Token replace AJAX, ensure no hidden
  // fields.
  if ($id === 0 && $display['type'] == 'hidden') {
    $field_type      = field_info_field_types($context['field']['type']);
    $display['type'] = $field_type['default_formatter'];
  }
}

/**
 * Generates a key to protect Token replacement AJAX callbacks.
 *
 * @param $token
 *
 * @return string
 */
function token_replace_ajax_access_key($token) {
  return substr(drupal_hmac_base64($token, drupal_get_private_key() . drupal_get_hash_salt()), 0, 8);
}
